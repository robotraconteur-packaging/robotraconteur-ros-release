//This file is automatically generated. DO NOT EDIT!

#include <RobotRaconteur.h>
#include <boost/signals2.hpp>
#include <boost/array.hpp>
#include <boost/container/static_vector.hpp>
#pragma once

#ifndef ROBOTRACONTEUR_ROBDEF_THUNK____com__robotraconteur__testing__TestService2____EXPORT
#define ROBOTRACONTEUR_ROBDEF_THUNK____com__robotraconteur__testing__TestService2____EXPORT
#endif

namespace com
{
namespace robotraconteur
{
namespace testing
{
namespace TestService2
{

class ROBOTRACONTEUR_ROBDEF_THUNK____com__robotraconteur__testing__TestService2____EXPORT ostruct2;
class ROBOTRACONTEUR_ROBDEF_THUNK____com__robotraconteur__testing__TestService2____EXPORT baseobj;
class ROBOTRACONTEUR_ROBDEF_THUNK____com__robotraconteur__testing__TestService2____EXPORT subobj;


class ROBOTRACONTEUR_ROBDEF_THUNK____com__robotraconteur__testing__TestService2____EXPORT ostruct2 : public RobotRaconteur::RRStructure {
public:
RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > a1;

virtual std::string RRType() {return "com.robotraconteur.testing.TestService2.ostruct2";  }
};

#ifndef BOOST_NO_CXX11_TEMPLATE_ALIASES
using ostruct2Ptr = RR_INTRUSIVE_PTR<ostruct2>;
#endif

class ROBOTRACONTEUR_ROBDEF_THUNK____com__robotraconteur__testing__TestService2____EXPORT baseobj : public virtual RobotRaconteur::RRObject
{
public:
virtual double get_d1()=0;
virtual void set_d1(double value)=0;

virtual RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > get_d2()=0;
virtual void set_d2(RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > value)=0;

virtual double func3(double d1, double d2)=0;

virtual boost::signals2::signal<void ()>& get_ev1()=0;

virtual RR_SHARED_PTR<subobj > get_o5()=0;

virtual RR_SHARED_PTR<RobotRaconteur::Pipe<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > > get_p1()=0;
virtual void set_p1(RR_SHARED_PTR<RobotRaconteur::Pipe<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > > value)=0;

virtual RR_SHARED_PTR<RobotRaconteur::Callback<boost::function<void(double, double) > > > get_cb2()=0;
virtual void set_cb2(RR_SHARED_PTR<RobotRaconteur::Callback<boost::function<void(double, double)> > > value)=0;

virtual RR_SHARED_PTR<RobotRaconteur::Wire<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > > get_w1()=0;
virtual void set_w1(RR_SHARED_PTR<RobotRaconteur::Wire<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > > value)=0;

virtual RR_SHARED_PTR<RobotRaconteur::ArrayMemory<double > > get_m1()=0;

virtual std::string RRType() {return "com.robotraconteur.testing.TestService2.baseobj";  }
};

#ifndef BOOST_NO_CXX11_TEMPLATE_ALIASES
using baseobjPtr = RR_SHARED_PTR<baseobj>;
#endif

class ROBOTRACONTEUR_ROBDEF_THUNK____com__robotraconteur__testing__TestService2____EXPORT subobj : public virtual RobotRaconteur::RRObject
{
public:
virtual double add_val(double v)=0;

virtual std::string RRType() {return "com.robotraconteur.testing.TestService2.subobj";  }
};

#ifndef BOOST_NO_CXX11_TEMPLATE_ALIASES
using subobjPtr = RR_SHARED_PTR<subobj>;
#endif

class ROBOTRACONTEUR_ROBDEF_THUNK____com__robotraconteur__testing__TestService2____EXPORT testexception3 : public RobotRaconteur::RobotRaconteurRemoteException
{
    public:
    testexception3(const std::string& message, std::string sub_name = "", RR_INTRUSIVE_PTR<RobotRaconteur::RRValue> param_ = RR_INTRUSIVE_PTR<RobotRaconteur::RRValue>()) : RobotRaconteur::RobotRaconteurRemoteException("com.robotraconteur.testing.TestService2.testexception3",message,sub_name,param_) {}
};
#ifndef BOOST_NO_CXX11_TEMPLATE_ALIASES
using testexception3Ptr = RR_SHARED_PTR<testexception3>;
#endif
}
}
}
}

