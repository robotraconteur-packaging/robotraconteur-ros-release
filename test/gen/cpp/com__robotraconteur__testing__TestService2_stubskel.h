//This file is automatically generated. DO NOT EDIT!

#include "com__robotraconteur__testing__TestService2.h"
// NOLINTBEGIN
#pragma once

namespace com
{
namespace robotraconteur
{
namespace testing
{
namespace TestService2
{

class ROBOTRACONTEUR_ROBDEF_THUNK____com__robotraconteur__testing__TestService2____EXPORT com__robotraconteur__testing__TestService2Factory : public virtual RobotRaconteur::ServiceFactory
{
public:
RR_OVIRTUAL std::string GetServiceName() RR_OVERRIDE;
RR_OVIRTUAL std::string DefString() RR_OVERRIDE;
RR_OVIRTUAL RR_SHARED_PTR<RobotRaconteur::StructureStub> FindStructureStub(boost::string_ref s) RR_OVERRIDE;
RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> PackStructure(const RR_INTRUSIVE_PTR<RobotRaconteur::RRStructure>& structin) RR_OVERRIDE;
RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::RRValue> UnpackStructure(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList>& mstructin) RR_OVERRIDE;
RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> PackPodArray(const RR_INTRUSIVE_PTR<RobotRaconteur::RRPodBaseArray>& structure) RR_OVERRIDE;
RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::RRPodBaseArray> UnpackPodArray(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList>& structure) RR_OVERRIDE;
RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> PackPodMultiDimArray(const RR_INTRUSIVE_PTR<RobotRaconteur::RRPodBaseMultiDimArray>& structure) RR_OVERRIDE;
RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::RRPodBaseMultiDimArray> UnpackPodMultiDimArray(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList>& structure) RR_OVERRIDE;
RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> PackNamedArray(const RR_INTRUSIVE_PTR<RobotRaconteur::RRNamedBaseArray>& structure) RR_OVERRIDE;
RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::RRNamedBaseArray> UnpackNamedArray(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList>& structure) RR_OVERRIDE;
RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> PackNamedMultiDimArray(const RR_INTRUSIVE_PTR<RobotRaconteur::RRNamedBaseMultiDimArray>& structure) RR_OVERRIDE ;
RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::RRNamedBaseMultiDimArray> UnpackNamedMultiDimArray(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList>& structure) RR_OVERRIDE;
RR_OVIRTUAL RR_SHARED_PTR<RobotRaconteur::ServiceStub> CreateStub(boost::string_ref objecttype, boost::string_ref path, const RR_SHARED_PTR<RobotRaconteur::ClientContext>& context) RR_OVERRIDE;
RR_OVIRTUAL RR_SHARED_PTR<RobotRaconteur::ServiceSkel> CreateSkel(boost::string_ref objecttype, boost::string_ref path, const RR_SHARED_PTR<RobotRaconteur::RRObject>& obj, const RR_SHARED_PTR<RobotRaconteur::ServerContext>& context) RR_OVERRIDE;
RR_OVIRTUAL void DownCastAndThrowException(RobotRaconteur::RobotRaconteurException& exp) RR_OVERRIDE;
RR_OVIRTUAL RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> DownCastException(const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>& exp) RR_OVERRIDE;
};

class ROBOTRACONTEUR_ROBDEF_THUNK____com__robotraconteur__testing__TestService2____EXPORT ostruct2_stub : public virtual RobotRaconteur::StructureStub
{
public:
ostruct2_stub(const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurNode>& node) : RobotRaconteur::StructureStub(node) {}
RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> PackStructure(const RR_INTRUSIVE_PTR<RobotRaconteur::RRValue>& s) RR_OVERRIDE ;
RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::RRStructure> UnpackStructure(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList>& m) RR_OVERRIDE ;
};

class ROBOTRACONTEUR_ROBDEF_THUNK____com__robotraconteur__testing__TestService2____EXPORT async_baseobj
{
// NOLINTBEGIN
public:
virtual void async_get_d1(boost::function<void (double,const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE) = 0;
virtual void async_set_d1(double value,boost::function<void (const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE) = 0;


virtual void async_get_d2(boost::function<void (const RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > >&,const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE) = 0;
virtual void async_set_d2(const RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > >& value,boost::function<void (const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE) = 0;


virtual void async_func3(double d1, double d2,boost::function<void (double, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE) = 0;


virtual void async_get_o5(boost::function<void(RR_SHARED_PTR<subobj>,const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&)> handler, int32_t timeout=RR_TIMEOUT_INFINITE)=0;

// NOLINTEND
};
class ROBOTRACONTEUR_ROBDEF_THUNK____com__robotraconteur__testing__TestService2____EXPORT async_subobj
{
// NOLINTBEGIN
public:
virtual void async_add_val(double v,boost::function<void (double, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE) = 0;


// NOLINTEND
};
class ROBOTRACONTEUR_ROBDEF_THUNK____com__robotraconteur__testing__TestService2____EXPORT baseobj_stub : public virtual baseobj, public virtual async_baseobj, public virtual RobotRaconteur::ServiceStub
{
public:
baseobj_stub(boost::string_ref, const RR_SHARED_PTR<RobotRaconteur::ClientContext>& c);

RR_OVIRTUAL void RRInitStub() RR_OVERRIDE ;
RR_OVIRTUAL double get_d1() RR_OVERRIDE;
RR_OVIRTUAL void set_d1(double value) RR_OVERRIDE;

RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > get_d2() RR_OVERRIDE;
RR_OVIRTUAL void set_d2(const RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > >& value) RR_OVERRIDE;

RR_OVIRTUAL double func3(double d1, double d2) RR_OVERRIDE;

RR_OVIRTUAL boost::signals2::signal<void ()>& get_ev1() RR_OVERRIDE;

RR_OVIRTUAL RR_SHARED_PTR<subobj > get_o5() RR_OVERRIDE;

RR_OVIRTUAL RR_SHARED_PTR<RobotRaconteur::Pipe<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > > get_p1() RR_OVERRIDE;
RR_OVIRTUAL void set_p1(const RR_SHARED_PTR<RobotRaconteur::Pipe<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > >& value) RR_OVERRIDE;

RR_OVIRTUAL RR_SHARED_PTR<RobotRaconteur::Callback<boost::function<void(double, double) > > > get_cb2() RR_OVERRIDE;
RR_OVIRTUAL void set_cb2(const RR_SHARED_PTR<RobotRaconteur::Callback<boost::function<void(double, double)> > >& value) RR_OVERRIDE;

RR_OVIRTUAL RR_SHARED_PTR<RobotRaconteur::Wire<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > > get_w1() RR_OVERRIDE;
RR_OVIRTUAL void set_w1(const RR_SHARED_PTR<RobotRaconteur::Wire<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > >& value) RR_OVERRIDE;

RR_OVIRTUAL RR_SHARED_PTR<RobotRaconteur::ArrayMemory<double > > get_m1() RR_OVERRIDE;


RR_OVIRTUAL void DispatchEvent(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m) RR_OVERRIDE;
RR_OVIRTUAL void DispatchPipeMessage(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m) RR_OVERRIDE;
RR_OVIRTUAL void DispatchWireMessage(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m) RR_OVERRIDE;
RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> CallbackCall(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m) RR_OVERRIDE;
RR_OVIRTUAL void RRClose() RR_OVERRIDE;
RR_OVIRTUAL RR_SHARED_PTR<RobotRaconteur::PipeClientBase> RRGetPipeClient(boost::string_ref membername) RR_OVERRIDE;
RR_OVIRTUAL RR_SHARED_PTR<RobotRaconteur::WireClientBase> RRGetWireClient(boost::string_ref membername) RR_OVERRIDE;
private:
boost::signals2::signal<void ()> rrvar_ev1;

RR_SHARED_PTR<RobotRaconteur::PipeClient<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > > rrvar_p1;
RR_SHARED_PTR<RobotRaconteur::CallbackClient<boost::function<void(double, double) > > > rrvar_cb2;
RR_SHARED_PTR<RobotRaconteur::WireClient<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > > rrvar_w1;
RR_SHARED_PTR<RobotRaconteur::ArrayMemoryClient<double > > rrvar_m1;
RR_OVIRTUAL void async_get_d1(boost::function<void (double,const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE) RR_OVERRIDE;
RR_OVIRTUAL void async_set_d1(double value,boost::function<void (const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE) RR_OVERRIDE;

protected:
virtual void rrend_get_d1(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>& err, boost::function< void (double ,const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > handler);
virtual void rrend_set_d1(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>& err, boost::function< void (const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > handler);
public:
RR_OVIRTUAL void async_get_d2(boost::function<void (const RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > >&,const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE) RR_OVERRIDE;
RR_OVIRTUAL void async_set_d2(const RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > >& value,boost::function<void (const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE) RR_OVERRIDE;

protected:
virtual void rrend_get_d2(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>& err, boost::function< void (const RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > >& ,const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > handler);
virtual void rrend_set_d2(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>& err, boost::function< void (const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > handler);
public:
RR_OVIRTUAL void async_func3(double d1, double d2,boost::function<void (double, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE) RR_OVERRIDE;

protected:
virtual void rrend_func3(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>& err, boost::function< void (double ,const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > handler);
public:
RR_OVIRTUAL void async_get_o5(boost::function<void(RR_SHARED_PTR<subobj>,const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&)> handler, int32_t timeout=RR_TIMEOUT_INFINITE) RR_OVERRIDE;

RR_OVIRTUAL std::string RRType() RR_OVERRIDE;
};

class ROBOTRACONTEUR_ROBDEF_THUNK____com__robotraconteur__testing__TestService2____EXPORT subobj_stub : public virtual subobj, public virtual async_subobj, public virtual RobotRaconteur::ServiceStub
{
public:
subobj_stub(boost::string_ref, const RR_SHARED_PTR<RobotRaconteur::ClientContext>& c);

RR_OVIRTUAL void RRInitStub() RR_OVERRIDE ;
RR_OVIRTUAL double add_val(double v) RR_OVERRIDE;


RR_OVIRTUAL void DispatchEvent(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m) RR_OVERRIDE;
RR_OVIRTUAL void DispatchPipeMessage(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m) RR_OVERRIDE;
RR_OVIRTUAL void DispatchWireMessage(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m) RR_OVERRIDE;
RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> CallbackCall(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m) RR_OVERRIDE;
RR_OVIRTUAL void RRClose() RR_OVERRIDE;
RR_OVIRTUAL RR_SHARED_PTR<RobotRaconteur::PipeClientBase> RRGetPipeClient(boost::string_ref membername) RR_OVERRIDE;
RR_OVIRTUAL RR_SHARED_PTR<RobotRaconteur::WireClientBase> RRGetWireClient(boost::string_ref membername) RR_OVERRIDE;
private:
RR_OVIRTUAL void async_add_val(double v,boost::function<void (double, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE) RR_OVERRIDE;

protected:
virtual void rrend_add_val(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>& err, boost::function< void (double ,const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>&) > handler);
public:
RR_OVIRTUAL std::string RRType() RR_OVERRIDE;
};


class ROBOTRACONTEUR_ROBDEF_THUNK____com__robotraconteur__testing__TestService2____EXPORT baseobj_skel : public virtual RobotRaconteur::ServiceSkel
{
public:
RR_OVIRTUAL void Init(boost::string_ref path, const RR_SHARED_PTR<RobotRaconteur::RRObject>& object, const RR_SHARED_PTR<RobotRaconteur::ServerContext>& context) RR_OVERRIDE;
RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> CallGetProperty(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m) RR_OVERRIDE;

RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> CallSetProperty(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m) RR_OVERRIDE;

RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> CallFunction(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m) RR_OVERRIDE;

RR_OVIRTUAL void ReleaseCastObject() RR_OVERRIDE;

RR_OVIRTUAL void RegisterEvents(const RR_SHARED_PTR<RobotRaconteur::RRObject>& rrobj1) RR_OVERRIDE;

RR_OVIRTUAL void UnregisterEvents(const RR_SHARED_PTR<RobotRaconteur::RRObject>& rrobj1) RR_OVERRIDE;

RR_OVIRTUAL RR_SHARED_PTR<RobotRaconteur::RRObject> GetSubObj(boost::string_ref, boost::string_ref) RR_OVERRIDE;

RR_OVIRTUAL void InitPipeServers(const RR_SHARED_PTR<RobotRaconteur::RRObject>& rrobj1) RR_OVERRIDE;

RR_OVIRTUAL void InitWireServers(const RR_SHARED_PTR<RobotRaconteur::RRObject>& rrobj1) RR_OVERRIDE;

RR_OVIRTUAL void DispatchPipeMessage(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, uint32_t e) RR_OVERRIDE;

RR_OVIRTUAL void DispatchWireMessage(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, uint32_t e) RR_OVERRIDE;

RR_OVIRTUAL void InitCallbackServers(const RR_SHARED_PTR<RobotRaconteur::RRObject>& o) RR_OVERRIDE;

RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> CallPipeFunction(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, uint32_t e) RR_OVERRIDE;

RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> CallWireFunction(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, uint32_t e) RR_OVERRIDE;

RR_OVIRTUAL RR_SHARED_PTR<void> GetCallbackFunction(uint32_t endpoint, boost::string_ref) RR_OVERRIDE;

RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> CallMemoryFunction(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, const RR_SHARED_PTR<RobotRaconteur::Endpoint>& e) RR_OVERRIDE;

RR_OVIRTUAL bool IsRequestNoLock(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m) RR_OVERRIDE;

RR_OVIRTUAL std::string GetObjectType() RR_OVERRIDE;
RR_SHARED_PTR<com::robotraconteur::testing::TestService2::baseobj > get_obj();

RR_SHARED_PTR<com::robotraconteur::testing::TestService2::async_baseobj > get_asyncobj();

protected:
static void rr_get_d1(RR_WEAK_PTR<com::robotraconteur::testing::TestService2::baseobj_skel> skel, double value, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>& err, const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, const RR_SHARED_PTR<RobotRaconteur::ServerEndpoint>& ep);
static void rr_get_d2(RR_WEAK_PTR<com::robotraconteur::testing::TestService2::baseobj_skel> skel, RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > value, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>& err, const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, const RR_SHARED_PTR<RobotRaconteur::ServerEndpoint>& ep);
static void rr_func3(RR_WEAK_PTR<com::robotraconteur::testing::TestService2::baseobj_skel> skel, double ret, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>& err, const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, RR_SHARED_PTR<RobotRaconteur::ServerEndpoint> ep);
 public:
void rr_ev1_Handler();
protected:boost::signals2::connection ev1_rrconnection;
bool rr_InitPipeServersRun;
bool rr_InitWireServersRun;
RR_SHARED_PTR<RobotRaconteur::PipeServer<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > > rr_p1_pipe;
RR_SHARED_PTR<RobotRaconteur::WireServer<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > > rr_w1_wire;
public: 
void rr_cb2_callback(uint32_t rrendpoint, double d1, double d2);
private:
RR_SHARED_PTR<RobotRaconteur::ArrayMemoryServiceSkel<double > > rr_m1_mem;

};

class ROBOTRACONTEUR_ROBDEF_THUNK____com__robotraconteur__testing__TestService2____EXPORT subobj_skel : public virtual RobotRaconteur::ServiceSkel
{
public:
RR_OVIRTUAL void Init(boost::string_ref path, const RR_SHARED_PTR<RobotRaconteur::RRObject>& object, const RR_SHARED_PTR<RobotRaconteur::ServerContext>& context) RR_OVERRIDE;
RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> CallGetProperty(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m) RR_OVERRIDE;

RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> CallSetProperty(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m) RR_OVERRIDE;

RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> CallFunction(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m) RR_OVERRIDE;

RR_OVIRTUAL void ReleaseCastObject() RR_OVERRIDE;

RR_OVIRTUAL void RegisterEvents(const RR_SHARED_PTR<RobotRaconteur::RRObject>& rrobj1) RR_OVERRIDE;

RR_OVIRTUAL void UnregisterEvents(const RR_SHARED_PTR<RobotRaconteur::RRObject>& rrobj1) RR_OVERRIDE;

RR_OVIRTUAL RR_SHARED_PTR<RobotRaconteur::RRObject> GetSubObj(boost::string_ref, boost::string_ref) RR_OVERRIDE;

RR_OVIRTUAL void InitPipeServers(const RR_SHARED_PTR<RobotRaconteur::RRObject>& rrobj1) RR_OVERRIDE;

RR_OVIRTUAL void InitWireServers(const RR_SHARED_PTR<RobotRaconteur::RRObject>& rrobj1) RR_OVERRIDE;

RR_OVIRTUAL void DispatchPipeMessage(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, uint32_t e) RR_OVERRIDE;

RR_OVIRTUAL void DispatchWireMessage(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, uint32_t e) RR_OVERRIDE;

RR_OVIRTUAL void InitCallbackServers(const RR_SHARED_PTR<RobotRaconteur::RRObject>& o) RR_OVERRIDE;

RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> CallPipeFunction(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, uint32_t e) RR_OVERRIDE;

RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> CallWireFunction(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, uint32_t e) RR_OVERRIDE;

RR_OVIRTUAL RR_SHARED_PTR<void> GetCallbackFunction(uint32_t endpoint, boost::string_ref) RR_OVERRIDE;

RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> CallMemoryFunction(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, const RR_SHARED_PTR<RobotRaconteur::Endpoint>& e) RR_OVERRIDE;

RR_OVIRTUAL bool IsRequestNoLock(const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m) RR_OVERRIDE;

RR_OVIRTUAL std::string GetObjectType() RR_OVERRIDE;
RR_SHARED_PTR<com::robotraconteur::testing::TestService2::subobj > get_obj();

RR_SHARED_PTR<com::robotraconteur::testing::TestService2::async_subobj > get_asyncobj();

protected:
static void rr_add_val(RR_WEAK_PTR<com::robotraconteur::testing::TestService2::subobj_skel> skel, double ret, const RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>& err, const RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>& m, RR_SHARED_PTR<RobotRaconteur::ServerEndpoint> ep);
 public:
protected:bool rr_InitPipeServersRun;
bool rr_InitWireServersRun;
public: 
private:

};


class ROBOTRACONTEUR_ROBDEF_THUNK____com__robotraconteur__testing__TestService2____EXPORT baseobj_default_impl : public virtual baseobj, public virtual RobotRaconteur::RRObject_default_impl
{
protected:
double rrvar_d1;
RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > rrvar_d2;
boost::signals2::signal<void ()> rrvar_ev1;
RR_SHARED_PTR<RobotRaconteur::Callback<boost::function<void(double, double) > > > rrvar_cb2;

public:
baseobj_default_impl();
RR_OVIRTUAL double get_d1() RR_OVERRIDE;
RR_OVIRTUAL void set_d1(double value) RR_OVERRIDE;

RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > get_d2() RR_OVERRIDE;
RR_OVIRTUAL void set_d2(const RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > >& value) RR_OVERRIDE;

RR_OVIRTUAL double func3(double d1, double d2) RR_OVERRIDE;

RR_OVIRTUAL boost::signals2::signal<void ()>& get_ev1() RR_OVERRIDE;

RR_OVIRTUAL RR_SHARED_PTR<subobj > get_o5() RR_OVERRIDE;

RR_OVIRTUAL RR_SHARED_PTR<RobotRaconteur::Pipe<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > > get_p1() RR_OVERRIDE;
RR_OVIRTUAL void set_p1(const RR_SHARED_PTR<RobotRaconteur::Pipe<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > >& value) RR_OVERRIDE;

RR_OVIRTUAL RR_SHARED_PTR<RobotRaconteur::Callback<boost::function<void(double, double) > > > get_cb2() RR_OVERRIDE;
RR_OVIRTUAL void set_cb2(const RR_SHARED_PTR<RobotRaconteur::Callback<boost::function<void(double, double)> > >& value) RR_OVERRIDE;

RR_OVIRTUAL RR_SHARED_PTR<RobotRaconteur::Wire<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > > get_w1() RR_OVERRIDE;
RR_OVIRTUAL void set_w1(const RR_SHARED_PTR<RobotRaconteur::Wire<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > >& value) RR_OVERRIDE;

RR_OVIRTUAL RR_SHARED_PTR<RobotRaconteur::ArrayMemory<double > > get_m1() RR_OVERRIDE;

RR_OVIRTUAL std::string RRType() RR_OVERRIDE {return "com.robotraconteur.testing.TestService2.baseobj";  }
};

class ROBOTRACONTEUR_ROBDEF_THUNK____com__robotraconteur__testing__TestService2____EXPORT subobj_default_impl : public virtual subobj, public virtual RobotRaconteur::RRObject_default_impl
{
protected:

public:
subobj_default_impl();
RR_OVIRTUAL double add_val(double v) RR_OVERRIDE;

RR_OVIRTUAL std::string RRType() RR_OVERRIDE {return "com.robotraconteur.testing.TestService2.subobj";  }
};


class ROBOTRACONTEUR_ROBDEF_THUNK____com__robotraconteur__testing__TestService2____EXPORT baseobj_default_abstract_impl : public virtual baseobj, public virtual RobotRaconteur::RRObject_default_impl
{
protected:
double rrvar_d1;
RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > rrvar_d2;
boost::signals2::signal<void ()> rrvar_ev1;
RR_SHARED_PTR<RobotRaconteur::Callback<boost::function<void(double, double) > > > rrvar_cb2;

public:
baseobj_default_abstract_impl();
RR_OVIRTUAL double get_d1() RR_OVERRIDE;
RR_OVIRTUAL void set_d1(double value) RR_OVERRIDE;

RR_OVIRTUAL RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > get_d2() RR_OVERRIDE;
RR_OVIRTUAL void set_d2(const RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > >& value) RR_OVERRIDE;

RR_OVIRTUAL double func3(double d1, double d2) RR_OVERRIDE;

RR_OVIRTUAL boost::signals2::signal<void ()>& get_ev1() RR_OVERRIDE;

RR_OVIRTUAL RR_SHARED_PTR<subobj > get_o5() RR_OVERRIDE;

RR_OVIRTUAL RR_SHARED_PTR<RobotRaconteur::Pipe<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > > get_p1() RR_OVERRIDE;
RR_OVIRTUAL void set_p1(const RR_SHARED_PTR<RobotRaconteur::Pipe<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > >& value) RR_OVERRIDE;

RR_OVIRTUAL RR_SHARED_PTR<RobotRaconteur::Callback<boost::function<void(double, double) > > > get_cb2() RR_OVERRIDE;
RR_OVIRTUAL void set_cb2(const RR_SHARED_PTR<RobotRaconteur::Callback<boost::function<void(double, double)> > >& value) RR_OVERRIDE;

RR_OVIRTUAL RR_SHARED_PTR<RobotRaconteur::Wire<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > > get_w1() RR_OVERRIDE;
RR_OVIRTUAL void set_w1(const RR_SHARED_PTR<RobotRaconteur::Wire<RR_INTRUSIVE_PTR<RobotRaconteur::RRArray<double > > > >& value) RR_OVERRIDE;

RR_OVIRTUAL RR_SHARED_PTR<RobotRaconteur::ArrayMemory<double > > get_m1() RR_OVERRIDE;

RR_OVIRTUAL std::string RRType() RR_OVERRIDE {return "com.robotraconteur.testing.TestService2.baseobj";  }
};

class ROBOTRACONTEUR_ROBDEF_THUNK____com__robotraconteur__testing__TestService2____EXPORT subobj_default_abstract_impl : public virtual subobj, public virtual RobotRaconteur::RRObject_default_impl
{
protected:

public:
subobj_default_abstract_impl();
RR_OVIRTUAL double add_val(double v) RR_OVERRIDE;

RR_OVIRTUAL std::string RRType() RR_OVERRIDE {return "com.robotraconteur.testing.TestService2.subobj";  }
};


}
}
}
}

// NOLINTEND

